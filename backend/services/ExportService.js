const PDFDocument = require('pdfkit');
const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = require('docx');
const fs = require('fs').promises;
const path = require('path');

class ExportService {
  constructor() {
    this.tempDir = path.join(__dirname, '../temp');
    this.ensureTempDir();
  }

  async ensureTempDir() {
    try {
      await fs.mkdir(this.tempDir, { recursive: true });
    } catch (error) {
      console.error('Failed to create temp directory:', error);
    }
  }

  // Export summary as PDF
  async exportSummaryToPDF(summary, includeMetadata = true) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          margin: 50,
          size: 'A4'
        });

        let chunks = [];
        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => {
          const pdfBuffer = Buffer.concat(chunks);
          resolve(pdfBuffer);
        });
        doc.on('error', reject);

        // Add title
        doc.fontSize(20)
           .font('Helvetica-Bold')
           .text(summary.title || 'Summary', { align: 'center' });

        doc.moveDown();

        // Add metadata if requested
        if (includeMetadata) {
          doc.fontSize(10)
             .font('Helvetica')
             .fillColor('gray');

          const metadata = [
            `Type: ${summary.summaryType}`,
            `Style: ${summary.style}`,
            `Target Audience: ${summary.targetAudience}`,
            `Generated: ${new Date(summary.createdAt).toLocaleDateString()}`,
            `Word Count: ${summary.metadata.wordCount || 'N/A'}`
          ];

          metadata.forEach(item => {
            doc.text(item);
          });

          doc.moveDown().fillColor('black');
        }

        // Add summary content
        doc.fontSize(12)
           .font('Helvetica')
           .text(summary.summaryText, {
             align: 'justify',
             lineGap: 4
           });

        // Add footer
        doc.fontSize(8)
           .fillColor('gray')
           .text(
             'Generated by AI Study Circle', 
             50, 
             doc.page.height - 50, 
             { align: 'center' }
           );

        doc.end();

      } catch (error) {
        reject(error);
      }
    });
  }

  // Export summary as Word document
  async exportSummaryToWord(summary, includeMetadata = true) {
    try {
      const children = [];

      // Add title
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: summary.title || 'Summary',
              bold: true,
              size: 32
            })
          ],
          heading: HeadingLevel.TITLE,
          alignment: AlignmentType.CENTER
        })
      );

      // Add metadata
      if (includeMetadata) {
        const metadata = [
          `Type: ${summary.summaryType}`,
          `Style: ${summary.style}`,
          `Target Audience: ${summary.targetAudience}`,
          `Generated: ${new Date(summary.createdAt).toLocaleDateString()}`,
          `Word Count: ${summary.metadata.wordCount || 'N/A'}`
        ];

        children.push(
          new Paragraph({
            children: [
              new TextRun({
                text: metadata.join(' | '),
                italics: true,
                size: 20
              })
            ],
            alignment: AlignmentType.CENTER
          })
        );

        children.push(new Paragraph({ text: '' })); // Empty line
      }

      // Add summary content
      const summaryParagraphs = summary.summaryText.split('\n\n');
      summaryParagraphs.forEach(paragraph => {
        if (paragraph.trim()) {
          children.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: paragraph.trim(),
                  size: 24
                })
              ],
              alignment: AlignmentType.JUSTIFY
            })
          );
        }
      });

      // Add footer
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Generated by AI Study Circle',
              italics: true,
              size: 18
            })
          ],
          alignment: AlignmentType.CENTER
        })
      );

      const doc = new Document({
        sections: [{
          properties: {},
          children: children
        }]
      });

      const buffer = await Packer.toBuffer(doc);
      return buffer;

    } catch (error) {
      throw new Error(`Word export failed: ${error.message}`);
    }
  }

  // Export exam as PDF
  async exportExamToPDF(exam, includeAnswers = false, includeMetadata = true) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          margin: 50,
          size: 'A4'
        });

        let chunks = [];
        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => {
          const pdfBuffer = Buffer.concat(chunks);
          resolve(pdfBuffer);
        });
        doc.on('error', reject);

        // Add title
        doc.fontSize(20)
           .font('Helvetica-Bold')
           .text(exam.title || 'Examination', { align: 'center' });

        doc.moveDown();

        // Add description and instructions
        if (exam.description) {
          doc.fontSize(12)
             .font('Helvetica-Bold')
             .text('Description:');
          doc.font('Helvetica')
             .text(exam.description);
          doc.moveDown();
        }

        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Instructions:');
        doc.font('Helvetica')
           .text(exam.instructions || 'Answer all questions to the best of your ability.');

        // Add metadata
        if (includeMetadata) {
          doc.moveDown()
             .fontSize(10)
             .fillColor('gray');

          const metadata = [
            `Total Questions: ${exam.configuration.totalQuestions}`,
            `Time Limit: ${exam.configuration.timeLimit || 'No limit'} minutes`,
            `Total Points: ${exam.metadata.totalPoints}`,
            `Passing Score: ${exam.configuration.passingScore}%`
          ];

          metadata.forEach(item => {
            doc.text(item);
          });

          doc.moveDown().fillColor('black');
        }

        // Add questions
        doc.fontSize(12).font('Helvetica');
        
        exam.questions.forEach((question, index) => {
          if (doc.y > 700) { // Check if we need a new page
            doc.addPage();
          }

          doc.moveDown()
             .font('Helvetica-Bold')
             .text(`${index + 1}. ${question.question} (${question.points} points)`);

          doc.font('Helvetica');

          // Add options for MCQ
          if (question.type === 'mcq' && question.options) {
            question.options.forEach((option, optIndex) => {
              const letter = String.fromCharCode(65 + optIndex); // A, B, C, D
              doc.text(`   ${letter}) ${option}`);
            });
          }

          // Add answer space for other question types
          if (question.type === 'short_answer') {
            doc.text('   Answer: ________________________');
          } else if (question.type === 'essay') {
            doc.text('   Answer:');
            // Add lines for essay answers
            for (let i = 0; i < 5; i++) {
              doc.text('   ________________________');
            }
          } else if (question.type === 'true_false') {
            doc.text('   ☐ True     ☐ False');
          } else if (question.type === 'fill_blank') {
            doc.text('   Answer: ________________________');
          }

          // Add answers and explanations if requested
          if (includeAnswers) {
            doc.moveDown(0.5)
               .fontSize(10)
               .fillColor('blue')
               .font('Helvetica-Bold')
               .text(`   Answer: ${question.correctAnswer}`);

            if (question.explanation) {
              doc.font('Helvetica')
                 .text(`   Explanation: ${question.explanation}`);
            }

            doc.fillColor('black').fontSize(12);
          }
        });

        // Add footer
        doc.fontSize(8)
           .fillColor('gray')
           .text(
             `Generated by AI Study Circle${includeAnswers ? ' - Answer Key' : ''}`, 
             50, 
             doc.page.height - 50, 
             { align: 'center' }
           );

        doc.end();

      } catch (error) {
        reject(error);
      }
    });
  }

  // Export exam as Word document
  async exportExamToWord(exam, includeAnswers = false, includeMetadata = true) {
    try {
      const children = [];

      // Add title
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: exam.title || 'Examination',
              bold: true,
              size: 32
            })
          ],
          heading: HeadingLevel.TITLE,
          alignment: AlignmentType.CENTER
        })
      );

      // Add description
      if (exam.description) {
        children.push(
          new Paragraph({
            children: [
              new TextRun({
                text: 'Description: ',
                bold: true,
                size: 24
              }),
              new TextRun({
                text: exam.description,
                size: 24
              })
            ]
          })
        );
      }

      // Add instructions
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Instructions: ',
              bold: true,
              size: 24
            }),
            new TextRun({
              text: exam.instructions || 'Answer all questions to the best of your ability.',
              size: 24
            })
          ]
        })
      );

      // Add metadata
      if (includeMetadata) {
        const metadata = [
          `Total Questions: ${exam.configuration.totalQuestions}`,
          `Time Limit: ${exam.configuration.timeLimit || 'No limit'} minutes`,
          `Total Points: ${exam.metadata.totalPoints}`,
          `Passing Score: ${exam.configuration.passingScore}%`
        ];

        children.push(
          new Paragraph({
            children: [
              new TextRun({
                text: metadata.join(' | '),
                italics: true,
                size: 20
              })
            ]
          })
        );
      }

      children.push(new Paragraph({ text: '' })); // Empty line

      // Add questions
      exam.questions.forEach((question, index) => {
        // Question number and text
        children.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `${index + 1}. ${question.question} (${question.points} points)`,
                bold: true,
                size: 24
              })
            ]
          })
        );

        // Add options for MCQ
        if (question.type === 'mcq' && question.options) {
          question.options.forEach((option, optIndex) => {
            const letter = String.fromCharCode(65 + optIndex);
            children.push(
              new Paragraph({
                children: [
                  new TextRun({
                    text: `   ${letter}) ${option}`,
                    size: 22
                  })
                ]
              })
            );
          });
        }

        // Add answer space
        if (question.type !== 'mcq') {
          children.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: '   Answer: ________________________',
                  size: 22
                })
              ]
            })
          );
        }

        // Add answers if requested
        if (includeAnswers) {
          children.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: `   Answer: ${question.correctAnswer}`,
                  bold: true,
                  color: '0000FF',
                  size: 20
                })
              ]
            })
          );

          if (question.explanation) {
            children.push(
              new Paragraph({
                children: [
                  new TextRun({
                    text: `   Explanation: ${question.explanation}`,
                    color: '0000FF',
                    size: 20
                  })
                ]
              })
            );
          }
        }

        children.push(new Paragraph({ text: '' })); // Empty line between questions
      });

      // Add footer
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `Generated by AI Study Circle${includeAnswers ? ' - Answer Key' : ''}`,
              italics: true,
              size: 18
            })
          ],
          alignment: AlignmentType.CENTER
        })
      );

      const doc = new Document({
        sections: [{
          properties: {},
          children: children
        }]
      });

      const buffer = await Packer.toBuffer(doc);
      return buffer;

    } catch (error) {
      throw new Error(`Word export failed: ${error.message}`);
    }
  }

  // Generate filename for exports
  generateFilename(type, format, title, includeAnswers = false) {
    const cleanTitle = title.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50);
    const timestamp = new Date().toISOString().split('T')[0];
    const answerSuffix = includeAnswers ? '_answers' : '';
    return `${type}_${cleanTitle}_${timestamp}${answerSuffix}.${format}`;
  }

  // Get content type for different formats
  getContentType(format) {
    const contentTypes = {
      'pdf': 'application/pdf',
      'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'json': 'application/json',
      'txt': 'text/plain',
      'md': 'text/markdown',
      'html': 'text/html'
    };
    return contentTypes[format] || 'application/octet-stream';
  }
}

module.exports = ExportService;